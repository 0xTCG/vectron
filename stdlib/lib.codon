import openmp as omp

from experimental.simd import Vec


NOVEC: Static[int] = 0

INT_SIZE: Static[int] = 64 if NOVEC == 1 else 16
size_t = Int[INT_SIZE]
LANE_SIZE: Static[int] = 32
vec_type = Vec[size_t, LANE_SIZE]
NUM_THREADS: Static[int] = 4


@extend
class Vec:
    def __bool__(self: Vec[T, N]) -> bool:
        raise ValueError("IR pass malfunctioned: cannot call bool on Vec")

    @llvm
    @pure
    @inline
    def __eq__(self: Vec[T, N], other: Vec[T, N]) -> Vec[u1, N]:
        %0 = icmp eq <{=N} x {=T}> %self, %other
        ret <{=N} x i1> %0
    
    @pure
    @inline
    def __eq__(self: Vec[T, N], other: int) -> Vec[u1, N]:
        return self == Vec[T, N](T(other))

    @llvm
    @pure
    @inline
    def add(self: Vec[T, N], other: Vec[T, N]) -> Vec[T, N]:
        %0 = add <{=N} x {=T}> %self, %other
        ret <{=N} x {=T}> %0

    @llvm
    @pure
    @inline
    def add(self: Vec[T, N], other: T) -> Vec[T, N]:
        %0 = insertelement <{=N} x {=T}> undef, {=T} %other, i32 0
        %1 = shufflevector <{=N} x {=T}> %0, <{=N} x {=T}> undef, <{=N} x i32> zeroinitializer
        %2 = add <{=N} x {=T}> %self, %1
        ret <{=N} x {=T}> %2

    def __add__(self: Vec[T, N], other) -> Vec[T, N]:
        _other = other if isinstance(other, Vec) else T(other)
        return self.add(_other)

    @llvm
    @pure
    @inline
    def sub(self: Vec[T, N], other: Vec[T, N]) -> Vec[T, N]:
        %0 = sub <{=N} x {=T}> %self, %other
        ret <{=N} x {=T}> %0

    @llvm
    @pure
    @inline
    def sub(self: Vec[T, N], other: T) -> Vec[T, N]:
        %0 = insertelement <{=N} x {=T}> undef, {=T} %other, i32 0
        %1 = shufflevector <{=N} x {=T}> %0, <{=N} x {=T}> undef, <{=N} x i32> zeroinitializer
        %2 = sub <{=N} x {=T}> %self, %1
        ret <{=N} x {=T}> %2

    @pure
    @inline
    def __sub__(self: Vec[T, N], other) -> Vec[T, N]:
        _other = other if isinstance(other, Vec) else T(other)
        return self.sub(_other)
    
    @llvm
    @pure
    @inline
    def mask(self: Vec[T, N], mask: Vec[u1, N], other: Vec[T, N]) -> Vec[T, N]:
        %0 = select <{=N} x i1> %mask, <{=N} x {=T}> %self, <{=N} x {=T}> %other
        ret <{=N} x {=T}> %0

    @llvm
    @pure
    @inline
    def max(self: Vec[i16, N], other: Vec[i16, N]) -> Vec[i16, N]:
        declare <{=N} x i16> @llvm.smax.v{=N}i16(<{=N} x i16>, <{=N} x i16>)
        %0 = call <{=N} x i16> @llvm.smax.v{=N}i16(<{=N} x i16> %self, <{=N} x i16> %other)
        ret <{=N} x i16> %0

    @pure
    @inline
    def scatter(self: Vec[T, N]) -> List[T]:
        return [self[i] for i in staticrange(N)]


@extend
class List:
    def __setitem__(self: List[vec_type], idx: int, val: size_t):
        self[idx] = vec_type(val)
    
    def __setitem__(self: List[vec_type], idx: int, val: int):
        self[idx] = size_t(val)
    
    def transpose(self: list[T]) -> list[T]:
        if not self:
            return self
        
        if isinstance(T, list[list]):
            compile_error("List.transpose: Cannot transpose dimension larger than 2")
        elif isinstance(T, list):
            rows, cols = len(self), len(self[0])
            return [[self[j][i] for j in range(rows)] for i in range(cols)]
        else:
            return self
    

def to_int_nucl(n):
    if n == "A":
        return size_t(0)
    if n == "C":
        return size_t(1)
    if n == "G":
        return size_t(2)
    if n == "T":
        return size_t(3)
    if n == "N":
        return size_t(-1)
    raise ValueError(f"Invalid nucl: {n}")

def canon(seqs):
    return [[to_int_nucl(c) for c in seq] for seq in seqs]

def print_ln(x: vec_type):
    for i in staticrange(LANE_SIZE):
        print(x[i])

def ternary(cmp, x, y):
    if isinstance(x, Vec) and isinstance(y, Vec):
        return x.mask(cmp, y)

    return vec_type(size_t(x)).mask(cmp, vec_type(size_t(y)))

def maximum(*args):
    if staticlen(args) == 0:
        compile_error("invalid args for max")
    
    if staticlen(args) == 1:
        return args[0]

    if staticlen(args) == 2:
        if isinstance(args[0], Vec) and isinstance(args[1], Vec):
            return args[0].max(args[1])
        elif isinstance(args[0], Vec):
            return args[0].max(vec_type(size_t(args[1])))
        elif isinstance(args[1], Vec):
            return args[1].max(vec_type(size_t(args[0])))
        else:
            return max(*args[:2])
    
    return maximum(maximum(*args[:2]), *args[2:])

def alpern(vec_foo, xs, ys):
    scores = [[size_t(0) for _ in range(len(ys))] for _ in range(len(xs))]

    if NOVEC == 1:
        for i in range(len(xs)):
            for j in range(len(ys)):
                scores[i][j] = vec_foo(xs[i], ys[j])
        return scores

    yst = ys.transpose()
    @par(num_threads=NUM_THREADS)
    for i in range(len(xs)):
        xvecs = [vec_type(nucl) for nucl in xs[i]]
        for j in range(len(ys) // LANE_SIZE):
            yvecs = [vec_type(row[j * LANE_SIZE:]) for row in yst]
            scores[i][j * LANE_SIZE:(j + 1) * LANE_SIZE] = vec_foo(xvecs, yvecs).scatter()

    return scores

class Cache:
    dp_mat: dict[int, list[list[vec_type]]]

    def _dpmat(self, *args, init: Static[int]):
        if staticlen(args) > 0:
            return [self._dpmat(*args[1:], init=init) for _ in range(args[0])]
        else:
            return init if NOVEC == 1 else vec_type(size_t(init))
    
    def dpmat(self, *args, init: Static[int]):
        if NOVEC == 0 and not isinstance(self.dp_mat, dict[int, list[list[vec_type]]]):
            compile_error("Set type of Cache.dp_mat to dict[int, list[list[vec_type]]] when running without NOVEC")
        if NOVEC == 1 and not isinstance(self.dp_mat, dict[int, list[list[int]]]):
            compile_error("Set type of Cache.dp_mat to dict[int, list[list[int]]] when running with NOVEC")

        thr_id = omp.get_thread_num()
        if NUM_THREADS == 1:
            assert thr_id == 0, "Internal error: threading"

        if not thr_id in self.dp_mat:
            self.dp_mat[thr_id] = self._dpmat(*args, init=init)

        return self.dp_mat[thr_id]

# Hardcoding caches size to avoid race issues in multithreading
caches = (Cache(), Cache(), Cache())


def dpmat(*args, init: Static[int] = 0, idx: Static[int] = 0):
    return caches[idx].dpmat(*args, init=init)
